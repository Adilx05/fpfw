// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a C4 community web by 
//
//     CommunityWeb.Generators.C4.Drivers, Version=2020.0.0.78, Culture=neutral, PublicKeyToken=null
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//     
//     INFO: For extending behaviour of each generated class create another partial 
//     class in same namespace (public partial class [ClassName] { })
//     Example: 
//     public partial class Driver
//     {
//         public partial void OnStart() // extends the class with method
//         {
//         }
//
//         public partial void OnTerminate() // extends the class with method
//         {
//         }
//     }
// </auto-generated>
// ------------------------------------------------------------------------------
using Gamanet.C4.Driver.SimpleDriver.Devices;
using Gamanet.C4.Fwk4.Interfaces;
using Gamanet.C4.SDK;
using Gamanet.C4.SDK.Enums.Devices;
using Gamanet.C4.SDK.Enums.Logs;
using Gamanet.C4.SDK.Framework4.Device.Attributes;
using Gamanet.C4.SDK.Framework4.Device.Builder;
using Gamanet.C4.SDK.Framework4.Device.Categories;
using Gamanet.C4.SDK.Framework4.Device.Interfaces;
using Gamanet.C4.SDK.Framework4.Device.PropertyConfigurator;
using Gamanet.C4.SimpleInterfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;


namespace Gamanet.C4.Driver.SimpleDriver
{
    /// <summary>
    /// The driver's entry point.
    /// </summary>
    [Driver("2bf619a9-bb5d-4f37-8fa3-7f014d5191c5", "SimpleDriver", "Simple Driver for education purposes",
     Platform.Any, Runtime.Any, OperatingSystemFamily.Any, -1)]
    [DriverCategory(DriverCategoryConst.AccessControl)]
    public partial class Driver : IPlugin
    {
        /// <summary>
        /// driver context field
        /// </summary>
        private IDriverContext _driverContext;

        /// <summary>
        /// The driver context.
        /// </summary>
        public IDriverContext DriverContext { get { return _driverContext; } }

        /// <summary>
        /// Send message
        /// </summary>
        public event EventHandler<MessageEventArgsV1> SendMessage;

        /// <summary>
        /// Initializes the driver
        /// </summary>
        /// <param name="id">driver root id</param>
        /// <param name="client">simple client sdk for data manipulation</param>
        /// <param name="ct">
        /// This cancellation token must be used as a parameter for all threads or async task calls created inside the driver.
        /// The main driver thread is canceled by hoster calling Terminate method of this interface.
        /// </param>
        /// <returns>true when successfully initialized, otherwise false</returns>
        public bool Init(Guid id, ISimpleClient iclient, CancellationToken token)
        {
            var client = (ISimpleClientV1)iclient;

            client.Config.TimeZone = TimeZoneInfo.Utc;

            // try create devices instances by c4 tree
            // and validate addresses - all duplicite addresses will be highlighted with this strategy
            var errors = new List<InvalidDevicePropertyValueException>();
            if (!new DeviceBuilder(new[] { GetType().Assembly }).TryCreateDriverContext(client, id, token, out _driverContext, out errors))
            {
                //Process errors without using driver context
                ProcessErrors(id, client, errors);
                return false;
            }

            DriverContext.DeviceLog.DriverInitiated(DriverContext.DeviceTree.Root.Device as BusController);
            DriverContext.StatusSender.Send(DriverContext.DeviceTree.Root.SimpleDevice.Id, DeviceStatusCategory.Starting);

            var customErrors = new List<Tuple<SimpleDeviceV1, string>>();
            ValidateDevices(_driverContext, ref customErrors);
            if (customErrors.Any())
            {
                customErrors.ForEach(e =>
                {
                    // trace that configuration validation has failed
                    DriverContext.TraceLog.Trace($"DeviceConfigurationError on {e.Item1.Name} Property: {e.Item2}", e.Item1.Id);
                    // set state to configuration Failure
                    DriverContext.StatusSender.Send(e.Item1.Id, DeviceStatusCategory.ConfigurationFailure);
                });

                DriverContext.DeviceLog.DriverStartFailure(DriverContext.DeviceTree.Root.Device as BusController);
                return false;
            }
            else
                OnInitialized();

            OnStart();

            DriverContext.DeviceLog.DriverStarted(DriverContext.DeviceTree.Root.Device as BusController);

            return true;
        }

        private void ProcessErrors(Guid id, ISimpleClientV1 client, List<InvalidDevicePropertyValueException> errors)
        {
            // create device logger, because we want to process invalid property exceptions
            var deviceLog = new DeviceLogger(client);

            // create driver trace service (driverId == rootId == busControllerId)
            var rootDevice = client.Devices.Get(id, Properties.None);
            var traceLog = new DriverTracer(id, rootDevice.Name);

            // create service for status sending
            var statusSender = new StatusSender(client);

            foreach (var e in errors)
            {
                // trace that configuration validation has failed
                traceLog.Error($"DeviceConfigurationError on {e.DeviceName} Property: {e.DevicePropertyName}", e.DeviceId);
                // push C4 log event ConfiguraitonErrorInvalidPropertyValue
                LogEvent(rootDevice.Id, LogCategory.ConfigurationErrorInvalidPropertyValue, nameof(LogCategory.ConfigurationErrorInvalidPropertyValue), client, new Dictionary<string, object>() { { "PropertyName", e.DevicePropertyName } });
                // set state to configuration Failure
                statusSender.Send(e.DeviceId, DeviceStatusCategory.ConfigurationFailure);
            }

            LogEvent(rootDevice.Id, LogCategory.DriverStartFailure, nameof(LogCategory.DriverStartFailure), client);
        }

        private static void LogEvent(Guid deviceId,
                                       Guid eventId,
                                       string eventName,
                                       ISimpleClientV1 client,
                                       Dictionary<string, object> parameters = default)
        {
            var log = new SimpleLogV1(Guid.NewGuid(), eventName, Guid.Empty, eventId)
            {
                Data = new Dictionary<string, object>
                {
                    ["DeviceId"] = deviceId,
                    ["SourceTime"] = DateTime.UtcNow
                }
            };

            if (parameters != null)
                foreach (var par in parameters)
                    log.Data.Add(par.Key, par.Value);

            client.Logs.Create(log);
        }

        /// <summary>
        /// Terminate the driver
        /// </summary>
        /// <returns></returns>
        public bool Terminate()
        {
            DriverContext.TraceLog.Trace("Terminating driver.");
            OnTerminate();

            DriverContext.TraceLog.Trace("Driver terminated.");
            DriverContext.DeviceLog.DriverStopped(DriverContext.DeviceTree.Root.Device as BusController);

            return true;
        }

        /// <summary>
        /// On message from c4 - driver is interested only for commands
        /// </summary>
        /// <param name="message"></param>
        public void OnMessage(MessageV1 message)
        {
            // driver is interested only for commands
            if (message.CategoryId != MessageCategory.Command) return;

            var cmd = ((SimpleCommandV1)message.SimpleEntity);

            OnCommand(message.DestinationId, cmd, cmd.Data.GetValueOrDefault<Guid>("IssuerPersonId"));
        }

        /// <summary>
        /// Deliver command to device
        /// </summary>
        /// <param name="targetDevice">Device that command was issued on</param>
        /// <param name="command">Issued command</param>
        /// <param name="userId">C4 User who issue command on device</param>
        void OnCommand(Guid targetDevice, SimpleCommandV1 command, Guid userId = default)
        {
            var device = DriverContext.DeviceTree.GetNode(targetDevice)?.Device as ICommandHandler;
            if (device == null) return;

            device.HandleCommand(command, userId);
        }

        /// <summary>
        /// Validate driver hierarchy and addresses. 
        /// Fill all errors into errors parameter. If everything is OK leave errors parameter empty.
        /// </summary>
        /// <param name="driverContext">the driver context, stores all the hierarchy</param>
        /// <param name="errors">list of detected errors per device instance</param>
        partial void ValidateDevices(IDriverContext driverContext, ref List<Tuple<SimpleDeviceV1, string>> errors);

        /// <summary>
        /// Driver successfully initialized, setup custom timezone if needed;
        /// </summary>
        partial void OnInitialized();

        /// <summary>
        /// Start custom services and do other startup logic. Driver is already considered as started;
        /// </summary>
        partial void OnStart();

        /// <summary>
        /// Terminate driver execution. Stop device communication and dispose all allocated resources.
        /// </summary>
        partial void OnTerminate();
    }
}